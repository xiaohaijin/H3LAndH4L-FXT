0a1
> #include <iostream>
3,4c4,5
< #include "SystemOfUnits.h"
< #include "PhysicalConstants.h"
---
> #include "StarClassLibrary/SystemOfUnits.h"
> #include "StarClassLibrary/PhysicalConstants.h"
6c7,8
< //#include "StBichsel/Bichsel.h"
---
> #include "StBichsel/Bichsel.h"
> #include "StMessMgr.h"
8c10,14
< #include <iostream>
---
> #include "StRoot/StPicoDstMaker/StPicoDst.h"
> #include "StRoot/StPicoDstMaker/StPicoDstMaker.h"
> #include "StRoot/StPicoEvent/StPicoEvent.h"
> #include "StRoot/StPicoEvent/StPicoTrack.h"
> #include "StRoot/StPicoEvent/StPicoBTofPidTraits.h" //TOF Info.
10,17d15
< #include "StMessMgr.h"
< #include "StMuDSTMaker/COMMON/StMuDstMaker.h"
< #include "StMuDSTMaker/COMMON/StMuTrack.h"
< #include "StMuDSTMaker/COMMON/StMuEvent.h"
< #include "StMuDSTMaker/COMMON/StMuBTofPidTraits.h" //TOF Info.
< #include "StMuDSTMaker/COMMON/StMuBTofHit.h"
< #include "StBTofHeader.h"
< #include "StStrangeMuDstMaker/StStrangeMuDstMaker.h"
19c17,18
< //#include "StStrangeMuDstMaker/StStrangeEvMuDst.hh"
---
> 
> #include "StDcaGeometry.h"
26,45c25
< #include "StDcaGeometry.h"
< 
< /////////////////////////////////////////////////////////
< /// was added by xiaohai(begin)
< /////////////////////////////////////////////////////////
< #define XIAOHAI
< 
< #ifdef XIAOHAI
< #include "tofPathLength.hh"
< #include "COMMON/StMuDstMaker.h"
< #include "COMMON/StMuTrack.h"
< #include "COMMON/StMuEvent.h"
< #include "COMMON/StMuBTofPidTraits.h" //TOF Info.
< #include "COMMON/StMuBTofHit.h"
< #include "StStrangeMuDstMaker.h"
< #include "StV0MuDst.hh"
< #endif
< /////////////////////////////////////////////////////////
< /// was added by xiaohai(end)
< ////////////////////////////////////////////////////////
---
> #include "TString.h"
49c29
< StV0Maker::StV0Maker(StMuDstMaker* maker, const char* name) : StMaker(name)
---
> StV0Maker::StV0Maker(StPicoDstMaker* maker, const char* name) : StMaker(name)
53c33
<     mMuDstMaker = maker; // Pass MuDst pointer to DstAnlysisMaker Class member functions
---
>     mPicoDstMaker = maker; // Pass PicoDst pointer to DstAnlysisMaker Class member functions
89,90c69,70
<         mCharge1 = 2; // He3 charge = 2.
<         mChargeV0 = 1; // V0 charge,Lambda=0; Xi- = -1; H3L = 1.
---
>         mCharge1 = 2; // proton charge = 1.
>         mChargeV0 = 1; // V0 charge,Lambda=0.
95,96c75,76
<         mCharge1 = -2; // antiHe3 charge= -2.
<         mChargeV0 = -1; // V0 charge,Lambda=0; antiXi- = 1; antiH3L = -1.
---
>         mCharge1 = -2; // antiproton charge= -1.
>         mChargeV0 = -1; // V0 charge,Lambda=0.
113,116c93,96
<     cutAbsVertexZLeEq = 50.0; /*!< done */
<     cutNHitsGr = 10; /*!< done */
<     cutNHitsDedxGr = 0; /*!< done */
<     cutPtGrEq = 0.1; /*!< done, this is not asymmetric. */
---
>     cutAbsVertexZLeEq = 25.0;
>     cutNHitsGr = 16;
>     cutNHitsDedxGr = 0;
>     cutPtGrEq = 0.15;
118c98
<     cutAbsNSigma2Le = 2.0; /*!< done */
---
>     cutAbsNSigma2Le = 3.0;
120,121c100,101
<     cutDca1GrEq = 0.4; /*!< done */
<     cutDca2GrEq = 0.4; /*!< done */
---
>     cutDca1GrEq = 0.001;
>     cutDca2GrEq = 0.001;
123,124c103,104
<     cutDca1to2LeEq = 1.5;
<     cutV0MassWidthLeEq = 0.01;
---
>     cutDca1to2LeEq = 0.05;
>     cutV0MassWidthLeEq = 0.5;
130,131c110,111
<     cutDcaV0Le = 1.0;
<     cutV0DecLenGrEq = 2.0;
---
>     cutDcaV0Le = 0.05;
>     cutV0DecLenGrEq = 0.02;
138c118
<     f_dedx_th1.open("/star/u/jhai/dedx/dedx_mean_helium3.dat");
---
>     f_dedx_th1.open("/star/u/pengliu/dedx/dedx_mean_helium3.dat");
151c131
<     f_dedx_th2.open("/star/u/jhai/dedx/dedx_mean_pi.dat");
---
>     f_dedx_th2.open("/star/u/pengliu/dedx/dedx_mean_pi.dat");
172,174c152,153
<     hNPrimVertex = new TH1F("PrimVertex", "Number of Primary Vertex", 10, 0.0, 10.0);
<     hVertexZ = new TH1F("VertexZ", "Event Vertex Z Position", nbins * 20, -200.0, 200.0);
<     hVertexZdiff = new TH1F("VertexZdiff", "Vertex Z Position(VPD-TPC)", nbins * 20, -200.0, 200.0);
---
>     hVertexZ = new TH1F("VertexZ", "Event Vertex Z Position", nbins * 20, -100.0, 100.0);
>     hVertexZdiff = new TH1F("VertexZdiff", "Vertex Z Position(VPD-TPC)", nbins * 20, -100.0, 100.0);
177d155
<     hPrimaryRefMult = new TH1F("PrimaryRefMult", "PrimaryRefMult", nbins * 10, 0.0, 1000.0);
186c164
<     hMassP = new TH2F("MassP", "Mass vs. Rigidity", nbins * 20, -10.0, 10.0, nbins * 160, 0.0, 16.0);
---
>     hMassP = new TH2F("MassP", "Mass vs. Rigidity", nbins * 20, -10.0, 10.0, nbins * 50, 0.0, 5.0);
195,196c173,174
<     hdau1MassP = new TH2F("dau1MassP", "dau1Mass vs. Rigidity", nbins * 20, -10.0, 10.0, nbins * 160, 0.0, 16.0);
<     hdau2MassP = new TH2F("dau2MassP", "dau2Mass vs. Rigidity", nbins * 20, -10.0, 10.0, nbins * 160, 0.0, 16.0);
---
>     hdau1MassP = new TH2F("dau1MassP", "dau1Mass vs. Rigidity", nbins * 20, -10.0, 10.0, nbins * 50, 0.0, 5.0);
>     hdau2MassP = new TH2F("dau2MassP", "dau2Mass vs. Rigidity", nbins * 20, -10.0, 10.0, nbins * 50, 0.0, 5.0);
262,263c240
<     mV0Tree->Branch("dau1nhitsposs", mV0Dst.dau1nhitsposs, "dau1nhitsposs[nv0]/I");
<     mV0Tree->Branch("dau1hftbits", mV0Dst.dau1hftbits, "dau1hftbits[nv0]/I");
---
>     mV0Tree->Branch("dau1nhitsmax", mV0Dst.dau1nhitsmax, "dau1nhitsmax[nv0]/I");
275a253,259
>     mV0Tree->Branch("dau1PXL1", mV0Dst.dau1PXL1, "dau1PXL1[nv0]/I");
>     mV0Tree->Branch("dau1PXL2", mV0Dst.dau1PXL2, "dau1PXL2[nv0]/I");
>     mV0Tree->Branch("dau1PXL3", mV0Dst.dau1PXL3, "dau1PXL3[nv0]/I");
>     mV0Tree->Branch("dau1IST1", mV0Dst.dau1IST1, "dau1IST1[nv0]/I");
>     mV0Tree->Branch("dau1IST2", mV0Dst.dau1IST2, "dau1IST2[nv0]/I");
>     mV0Tree->Branch("dau1SSD1", mV0Dst.dau1SSD1, "dau1SSD1[nv0]/I");
>     mV0Tree->Branch("dau1SSD2", mV0Dst.dau1SSD2, "dau1SSD2[nv0]/I");
283,284c267
<     mV0Tree->Branch("dau2nhitsposs", mV0Dst.dau2nhitsposs, "dau2nhitsposs[nv0]/I");
<     mV0Tree->Branch("dau2hftbits", mV0Dst.dau2hftbits, "dau2hftbits[nv0]/I");
---
>     mV0Tree->Branch("dau2nhitsmax", mV0Dst.dau2nhitsmax, "dau2nhitsmax[nv0]/I");
296a280,286
>     mV0Tree->Branch("dau2PXL1", mV0Dst.dau2PXL1, "dau2PXL1[nv0]/I");
>     mV0Tree->Branch("dau2PXL2", mV0Dst.dau2PXL2, "dau2PXL2[nv0]/I");
>     mV0Tree->Branch("dau2PXL3", mV0Dst.dau2PXL3, "dau2PXL3[nv0]/I");
>     mV0Tree->Branch("dau2IST1", mV0Dst.dau2IST1, "dau2IST1[nv0]/I");
>     mV0Tree->Branch("dau2IST2", mV0Dst.dau2IST2, "dau2IST2[nv0]/I");
>     mV0Tree->Branch("dau2SSD1", mV0Dst.dau2SSD1, "dau2SSD1[nv0]/I");
>     mV0Tree->Branch("dau2SSD2", mV0Dst.dau2SSD2, "dau2SSD2[nv0]/I");
349a340
> 
360c351
<     StMuEvent* muEvent = mMuDstMaker->muDst()->event();
---
>     StPicoEvent* mPicoEvent = mPicoDstMaker->picoDst()->event();
362c353
<     if (!muEvent)
---
>     if (!mPicoEvent)
365c356
<     hNPrimVertex->Fill(mMuDstMaker->muDst()->numberOfPrimaryVertices());
---
>     StThreeVectorF pv(-999.0, -999.0, -999.0);
367c358
<     StThreeVectorF pv = muEvent->primaryVertexPosition();
---
>     pv = mPicoEvent->primaryVertex();
368a360
>     //	cout<<pv.x()<<"        "<<pv.y()<<"     "<<pv.z()<<endl;
378c370
<     //	select mb and central trigger
---
>     //	select mb trigger
380,385c372,376
<     //////////////////////////////////////////////////////////////
<     //     This was comment by xiaohai.
<     //////////////////////////////////////////////////////////////
< 
<     if ((!muEvent->triggerIdCollection().nominal().isTrigger(1)))
<         return kStOK;
---
>     //	 if((!mPicoEvent->isTrigger(450050)) &&
>     //	    (!mPicoEvent->isTrigger(450060)) &&
>     //	    (!mPicoEvent->isTrigger(450005)) &&
>     //	    (!mPicoEvent->isTrigger(450015)) &&
>     //	    (!mPicoEvent->isTrigger(450025)))return kStOK ;
388,391c379,382
<     hVertexZ->Fill(muEvent->primaryVertexPosition().z()); // Make histogram of the vertex Z distribution
<     //  Float_t temprefMult = muEvent->refMult();
<     Float_t temprefMult = muEvent->grefmult(); // for Run14.
<     //  hNRefMult->Fill(temprefMult);
---
>     hVertexZ->Fill(pv.z()); // Make histogram of the vertex Z distribution
>     //	Float_t temprefMult = mPicoEvent->refMult();
>     Float_t temprefMult = mPicoEvent->grefMult(); // for Run14.
>     hNRefMult->Fill(temprefMult);
394,398c385
<     ///////////////////////////////////////////////
<     // This was modified by xiaohai.
<     ///////////////////////////////////////////////
<     // if (fabs(muEvent->primaryVertexPosition().z()) > cutAbsVertexZLeEq) return kStOK;
<     if (muEvent->primaryVertexPosition().z() > 212 || muEvent->primaryVertexPosition().z() < 210) {
---
>     if (fabs(pv.z()) > cutAbsVertexZLeEq)
400,403c387,389
<     }
<     mV0Dst.primvertexX = muEvent->primaryVertexPosition().x();
<     mV0Dst.primvertexY = muEvent->primaryVertexPosition().y();
<     mV0Dst.primvertexZ = muEvent->primaryVertexPosition().z();
---
>     mV0Dst.primvertexX = pv.x();
>     mV0Dst.primvertexY = pv.y();
>     mV0Dst.primvertexZ = pv.z();
412,414c398
<     StBTofHeader* mBTofHeader = mMuDstMaker->muDst()->btofHeader();
<     if (mBTofHeader)
<         mvpdVz = mBTofHeader->vpdVz();
---
>     mvpdVz = mPicoEvent->vzVpd();
417,418c401,402
<     mV0Dst.eventid = muEvent->eventId();
<     mV0Dst.runid = muEvent->runInfo().runId();
---
>     mV0Dst.eventid = mPicoEvent->eventId();
>     mV0Dst.runid = mPicoEvent->runId();
421c405
<     hVertexZdiff->Fill(mvpdVz - muEvent->primaryVertexPosition().z());
---
>     hVertexZdiff->Fill(mvpdVz - pv.z());
427,428c411
<     // certain centrality. always make sure
<     // it is filled AFTER event selection!
---
>                                         // certain centrality. always make sure it is filled AFTER event selection!
430,431c413
<     Double_t magn = muEvent->runInfo().magneticField();
<     //	Double_t magn = muEvent->magneticField();	//checked! the same as above
---
>     Double_t magn = mPicoEvent->bField();
437,473c419,425
<     //  Get 'track' data, make cuts on tracks, do physics analysis, histogram results.
<     //  Create a TObject array containing the global tracks or the primary tracks.
<     TObjArray* tracks = mMuDstMaker->muDst()->globalTracks();
<     //	TObjArray* tracks = mMuDstMaker->muDst()->primaryTracks();
<     TObjArrayIter GetTracks(tracks); // Create an iterator to step through the tracks
<     hNRefMult->Fill(tracks->GetEntries());
<     hPrimaryRefMult->Fill(mMuDstMaker->muDst()->primaryTracks()->GetEntries());
<     StMuTrack* track = 0; // Pointer to a track
< 
<     //	Main loop for Iterating over tracks
<     while ((track = (StMuTrack*)GetTracks.Next())) {
<         short flag = track->flag();
<         unsigned short nHitsDedx = track->nHitsDedx(); // added dEdx Hits to restrict the background!
<         unsigned short nHitsFit = track->nHitsFit(kTpcId);
<         short charge = track->charge();
<         double nsigmapion = track->nSigmaPion();
<         double nsigmaproton = track->nSigmaProton();
<         double nsigmakaon = track->nSigmaKaon();
<         double dedx = track->dEdx();
<         int trackid = track->id();
<         float tracketa = track->eta();
<         StMuBTofPidTraits tofPid = (StMuBTofPidTraits)track->btofPidTraits();
< 
<         StPhysicalHelixD helix = track->helix(); // inner helix. good for dca to PV.
< 
<         //   if (track->index2Cov() < 0) continue;
<         //   StDcaGeometry* dcaG = mMuDstMaker->muDst()->covGlobTracks(track->index2Cov());
<         //   if (!dcaG) {
<         //     cout << "No dca Geometry for this track !!!" << endl;
<         //     continue;
<         //   }
<         //   StPhysicalHelixD helix = dcaG->helix();
< 
<         StThreeVectorD p = helix.momentum(magn * kilogauss); // momentum at origin
<         StThreeVectorD origin = helix.origin(); // origin of helix
<         double pathlength = helix.pathLength(
<             pv, false); // do scan periods.NOTE:the default is false.this is not necessary for tracks with pt>0.15GeV/c
---
>     //	Get 'track' data, make cuts on tracks, do physics analysis, histogram results.
> 
>     int nTracks = mPicoDstMaker->picoDst()->numberOfTracks();
> 
>     for (int i = 0; i < nTracks; i++) {
>         if (i > 100000)
>             break;
475c427,455
<         StThreeVectorF dca = helix.at(pathlength) - pv;
---
>         StPicoTrack* track = mPicoDstMaker->picoDst()->track(i);
>         if (!track)
>             continue;
> 
>         // HFT hit map information.
>         bool isHFT = track->isHFTTrack();
>         if (!isHFT)
>             continue;
>         //=======================================================================
> 
>         Int_t nHitsDedx = track->nHitsDedx(); // added dEdx Hits to restrict the background!
>         Int_t nHitsFit = track->nHitsFit();
>         Int_t nHitsMax = track->nHitsMax();
>         Short_t charge = track->charge();
>         Float_t nsigmapion = track->nSigmaPion();
>         Float_t nsigmaproton = track->nSigmaProton();
>         Float_t nsigmakaon = track->nSigmaKaon();
>         Float_t nsigmae = track->nSigmaElectron();
>         Float_t dedx = track->dEdx() * 1.0E-6;
>         Int_t trackid = track->id();
>         StPhysicalHelixD helix = track->helix(magn);
> 
>         StThreeVectorF p = helix.momentumAt(helix.pathLength(pv), magn * kilogauss);
> 
>         // dca information.
>         double dca = helix.geometricSignedDistance(pv);
> 
>         // TOF information.
>         int index2tof = track->bTofPidTraitsIndex();
477a458
>         float btofMatchFlag = -999.0;
479,489c460,474
<         if (tofPid.beta() > 0.0) {
<             tofbeta = tofPid.beta();
<             if (tofbeta < 1e-4 && dca.mag() < 3.0) {
<                 StThreeVectorF btofHitPos = tofPid.position();
<                 StThreeVectorF pVtx = muEvent->primaryVertexPosition();
<                 float L = tofPathLength(&pVtx, &btofHitPos, helix.curvature());
<                 float tof = tofPid.timeOfFlight();
<                 if (tof > 0)
<                     tofbeta = L / (tof * (C_C_LIGHT / 1.e9));
<                 else
<                     tofbeta = -999.0;
---
>         if (index2tof >= 0.0) {
>             StPicoBTofPidTraits* tofPid = mPicoDstMaker->picoDst()->btofPidTraits(index2tof);
>             btofMatchFlag = tofPid->btofMatchFlag();
>             if (tofPid) {
>                 tofbeta = tofPid->btofBeta();
> 
>                 if (tofbeta < 1E-4 && fabs(dca) < 3.0) {
>                     StThreeVectorF btofHitPos = tofPid->btofHitPos();
>                     float L = tofPathLength(&pv, &btofHitPos, helix.curvature());
>                     float tof = tofPid->btof();
>                     if (tof > 0.0)
>                         tofbeta = L / (tof * (C_C_LIGHT / 1.0E9)); // C_C_LIGHT = 2.99792E+10;
>                     else
>                         tofbeta = -999.0;
>                 }
493,494c478
<         if (tofbeta > 0.0)
<             tofmass = p.mag2() * (1.0 / (tofbeta * tofbeta) - 1.0); //(GeV/c^2)
---
>         tofmass = sqrt(p.mag2() * (1.0 / (tofbeta * tofbeta) - 1.0)); //(GeV/c^2)
497c481
<         if (nHitsFit <= cutNHitsGr)
---
>         if (abs(nHitsFit) <= cutNHitsGr)
499,503c483
<         if (nHitsDedx <= cutNHitsDedxGr)
<             continue;
<         if (flag <= 0 || flag >= 1000)
<             continue;
<         // if(track->bad())continue;
---
>         //		if(abs(nHitsDedx)<=cutNHitsDedxGr)continue;
506,516c486,489
< 
<         /*! This was modified by xiaohai. */
<         // if (fabs(track->eta()) > 1.0) continue;  // 1.0 to 1.5 to include more He3, pion should keep (-1.,1.0)
<         //    if (track->eta() < -1.8 || track->eta() > 0.2) {
<         //     continue;
<         //  }
< 
<         if (Float_t(nHitsFit) / Float_t(track->nHitsPoss()) < 0.52)
<             continue;
<         if (Float_t(nHitsFit) / Float_t(track->nHitsPoss()) > 1.02)
<             continue;
---
>         if (fabs(p.pseudoRapidity()) > 1.0)
>             continue; // 1.0 to 1.5 to include more He3, pion should keep (-1.,1.0)
>         //		if(Float_t(abs(nHitsFit))/Float_t(abs(nHitMax))continue;
>         //		if(Float_t(abs(nHitsFit))/Float_t(abs(nHitMax))continue;
518a492,493
>         if (fabs(dca) > 3.0)
>             continue;
526c501
<             hInvBetaP->Fill(p.mag() * charge, 1.0 / tofbeta); // beta vs. ragidity
---
>             hInvBetaP->Fill(p.mag() * charge, 1.0 / tofbeta); // beta vs. rigidity.
528c503
<         hDcaP->Fill(p.mag() * charge, dca.mag()); // Dca vs. rigidity.
---
>         hDcaP->Fill(p.mag() * charge, fabs(dca)); // Dca vs. rigidity.
531,532c506,507
<         // in mom p/q,should be
<         // corrected here!
---
>                                                                                                 // in mom p/q,should be
>                                                                                                 // corrected here!
534,535c509,510
<         // in mom p/q,should be
<         // corrected here!
---
>                                                                                                 // in mom p/q,should be
>                                                                                                 // corrected here!
538c513
<         if (charge == mCharge1 / abs(mCharge1) && fabs(nsigmaproton) < cutAbsNSigma2Le) {
---
>         if (charge == mCharge1 / abs(mCharge1) && dau1Z > -0.2) {
549c524
<             if (dca.mag() < cutDca1GrEq)
---
>             if (fabs(dca) < cutDca1GrEq)
566c541
<             mDauDcaVec1.push_back(dca.mag());
---
>             mDauDcaVec1.push_back(fabs(dca));
584c559
<             if (dca.mag() < cutDca2GrEq)
---
>             if (fabs(dca) < cutDca2GrEq)
601c576
<             mDauDcaVec2.push_back(dca.mag());
---
>             mDauDcaVec2.push_back(fabs(dca));
614a590,592
>     //	cout<<"@@@@@@@@@@@@@@@@@"<<mDauVec1.size()<<endl;
>     //	cout<<"#################"<<mDauVec2.size()<<endl;
> 
621c599
<         StMuTrack* track1 = mDauVec1[i];
---
>         StPicoTrack* track1 = mDauVec1[i];
624,632c602
<         //    if (track1->index2Cov() < 0) continue;
<         //    StDcaGeometry* dcaG1 = mMuDstMaker->muDst()->covGlobTracks(track1->index2Cov());
<         //    if (!dcaG1) {
<         //      cout << "No dca Geometry for this track !!!" << endl;
<         //      continue;
<         //    }
<         //    StPhysicalHelixD helix1 = dcaG1->helix();
< 
<         StPhysicalHelixD helix1 = track1->helix(); // inner helix. good for dca to PV.
---
>         StPhysicalHelixD helix1 = track1->helix(magn);
642c612
<             StMuTrack* track2 = mDauVec2[j];
---
>             StPicoTrack* track2 = mDauVec2[j];
645,653c615
<             //  if (track2->index2Cov() < 0) continue;
<             //  StDcaGeometry* dcaG2 = mMuDstMaker->muDst()->covGlobTracks(track2->index2Cov());
<             //  if (!dcaG2) {
<             //    cout << "No dca Geometry for this track !!!" << endl;
<             //    continue;
<             //  }
<             //  StPhysicalHelixD helix2 = dcaG2->helix();
< 
<             StPhysicalHelixD helix2 = track2->helix(); // inner helix. good for dca to PV.
---
>             StPhysicalHelixD helix2 = track2->helix(magn);
726d687
< 
746d706
< 
753,754c713,756
<             StMuBTofPidTraits tofPid1 = (StMuBTofPidTraits)track1->btofPidTraits();
<             StMuBTofPidTraits tofPid2 = (StMuBTofPidTraits)track2->btofPidTraits();
---
>             int dau1index2tof = track1->bTofPidTraitsIndex();
>             int dau2index2tof = track2->bTofPidTraitsIndex();
> 
>             StPicoBTofPidTraits* tofPid1 = 0;
>             StPicoBTofPidTraits* tofPid2 = 0;
> 
>             if (dau1index2tof > 0)
>                 tofPid1 = mPicoDstMaker->picoDst()->btofPidTraits(dau1index2tof);
>             if (dau2index2tof > 0)
>                 tofPid2 = mPicoDstMaker->picoDst()->btofPidTraits(dau2index2tof);
> 
>             int mPXL1Flag1 = 0;
>             int mPXL2Flag1 = 0;
>             int mPXL3Flag1 = 0;
>             int mIST1Flag1 = 0;
>             int mIST2Flag1 = 0;
>             int mSSD1Flag1 = 0;
>             int mSSD2Flag1 = 0;
>             int mPXL1Flag2 = 0;
>             int mPXL2Flag2 = 0;
>             int mPXL3Flag2 = 0;
>             int mIST1Flag2 = 0;
>             int mIST2Flag2 = 0;
>             int mSSD1Flag2 = 0;
>             int mSSD2Flag2 = 0;
> 
>             int hitMapHFT1 = track1->hftHitsMap();
>             int hitMapHFT2 = track2->hftHitsMap();
> 
>             mPXL1Flag1 = hitMapHFT1 & 0x1;
>             mPXL2Flag1 = (hitMapHFT1 >> 1) & 0x1;
>             mPXL3Flag1 = (hitMapHFT1 >> 2) & 0x1;
>             mIST1Flag1 = (hitMapHFT1 >> 3) & 0x1;
>             mIST2Flag1 = (hitMapHFT1 >> 4) & 0x1;
>             mSSD1Flag1 = (hitMapHFT1 >> 5) & 0x1;
>             mSSD2Flag1 = (hitMapHFT1 >> 6) & 0x1;
> 
>             mPXL1Flag2 = hitMapHFT2 & 0x1;
>             mPXL2Flag2 = (hitMapHFT2 >> 1) & 0x1;
>             mPXL3Flag2 = (hitMapHFT2 >> 2) & 0x1;
>             mIST1Flag2 = (hitMapHFT2 >> 3) & 0x1;
>             mIST2Flag2 = (hitMapHFT2 >> 4) & 0x1;
>             mSSD1Flag2 = (hitMapHFT2 >> 5) & 0x1;
>             mSSD2Flag2 = (hitMapHFT2 >> 6) & 0x1;
783c785
<             mV0Dst.dau1nhitsfit[nV0] = track1->nHitsFit(kTpcId);
---
>             mV0Dst.dau1nhitsfit[nV0] = track1->nHitsFit();
785,787c787,790
<             mV0Dst.dau1nhitsposs[nV0] = track1->nHitsPoss();
<             mV0Dst.dau1eta[nV0] = track1->eta();
<             mV0Dst.dau1nsigma[nV0] = track1->nSigmaProton();
---
>             mV0Dst.dau1nhitsmax[nV0] = track1->nHitsMax();
>             mV0Dst.dau1eta[nV0]
>                 = track1->helix(magn).momentumAt(track1->helix(magn).pathLength(pv), magn * kilogauss).pseudoRapidity();
>             mV0Dst.dau1nsigma[nV0] = 0.0;
794c797
<             mV0Dst.dau1hftbits[nV0] = track1->topologyMap().data(0);
---
>             //		 mV0Dst.dau1hftbits[nV0]       = track1->topologyMap().data(0);
796,799c799,818
<             mV0Dst.dau1diffinvbeta[nV0] = mDauDiffInvBetaVec1[i];
<             mV0Dst.dau1beta[nV0] = mDauBetaVec1[i];
<             mV0Dst.dau1toflocaly[nV0] = tofPid1.yLocal();
<             mV0Dst.dau1toflocalz[nV0] = tofPid1.zLocal();
---
> 
>             if (dau1index2tof > 0) {
>                 mV0Dst.dau1beta[nV0] = mDauBetaVec1[i];
>                 mV0Dst.dau1diffinvbeta[nV0] = mDauDiffInvBetaVec1[i];
>                 mV0Dst.dau1toflocaly[nV0] = tofPid1->btofYLocal();
>                 mV0Dst.dau1toflocalz[nV0] = tofPid1->btofZLocal();
>             } else {
>                 mV0Dst.dau1beta[nV0] = -999.0;
>                 mV0Dst.dau1diffinvbeta[nV0] = -999.0;
>                 mV0Dst.dau1toflocaly[nV0] = -999.0;
>                 mV0Dst.dau1toflocalz[nV0] = -999.0;
>             }
> 
>             mV0Dst.dau1PXL1[nV0] = mPXL1Flag1;
>             mV0Dst.dau1PXL2[nV0] = mPXL2Flag1;
>             mV0Dst.dau1PXL3[nV0] = mPXL3Flag1;
>             mV0Dst.dau1IST1[nV0] = mIST1Flag1;
>             mV0Dst.dau1IST2[nV0] = mIST2Flag1;
>             mV0Dst.dau1SSD1[nV0] = mSSD1Flag1;
>             mV0Dst.dau1SSD2[nV0] = mSSD2Flag1;
803c822
<             mV0Dst.dau2nhitsfit[nV0] = track2->nHitsFit(kTpcId);
---
>             mV0Dst.dau2nhitsfit[nV0] = track2->nHitsFit();
805,806c824,826
<             mV0Dst.dau2nhitsposs[nV0] = track2->nHitsPoss();
<             mV0Dst.dau2eta[nV0] = track2->eta();
---
>             mV0Dst.dau2nhitsmax[nV0] = track2->nHitsMax();
>             mV0Dst.dau2eta[nV0]
>                 = track2->helix(magn).momentumAt(track2->helix(magn).pathLength(pv), magn * kilogauss).pseudoRapidity();
814c834
<             mV0Dst.dau2hftbits[nV0] = track2->topologyMap().data(0);
---
>             //		 mV0Dst.dau2hftbits[nV0]       = track2->topologyMap().data(0);
816,819c836,856
<             mV0Dst.dau2diffinvbeta[nV0] = mDauDiffInvBetaVec2[j];
<             mV0Dst.dau2beta[nV0] = mDauBetaVec2[j];
<             mV0Dst.dau2toflocaly[nV0] = tofPid2.yLocal();
<             mV0Dst.dau2toflocalz[nV0] = tofPid2.zLocal();
---
> 
>             if (dau2index2tof > 0) {
>                 mV0Dst.dau2beta[nV0] = mDauBetaVec2[j];
>                 mV0Dst.dau2diffinvbeta[nV0] = mDauDiffInvBetaVec2[j];
>                 mV0Dst.dau2toflocaly[nV0] = tofPid2->btofYLocal();
>                 mV0Dst.dau2toflocalz[nV0] = tofPid2->btofZLocal();
>             } else {
>                 mV0Dst.dau2beta[nV0] = -999.0;
>                 mV0Dst.dau2diffinvbeta[nV0] = -999.0;
>                 mV0Dst.dau2toflocaly[nV0] = -999.0;
>                 mV0Dst.dau2toflocalz[nV0] = -999.0;
>             }
> 
>             mV0Dst.dau2PXL1[nV0] = mPXL1Flag2;
>             mV0Dst.dau2PXL2[nV0] = mPXL2Flag2;
>             mV0Dst.dau2PXL3[nV0] = mPXL3Flag2;
>             mV0Dst.dau2IST1[nV0] = mIST1Flag2;
>             mV0Dst.dau2IST2[nV0] = mIST2Flag2;
>             mV0Dst.dau2SSD1[nV0] = mSSD1Flag2;
>             mV0Dst.dau2SSD2[nV0] = mSSD2Flag2;
> 
823c860
<             // mV0Vec.push_back(v0data);
---
>             //		 mV0Vec.push_back(v0data);
848c885
<     // mV0Vec.clear();
---
>     //	mV0Vec.clear();
865c902
<     return kStOK;
---
>     return kStOk;
